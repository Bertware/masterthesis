\begin{Verbatim}[commandchars=\\\{\}]
		\PYG{c+c1}{// Results? Return data}
		\PYG{n}{Route}\PYG{o}{[]} \PYG{n}{routes} \PYG{o}{=} \PYG{k}{new} \PYG{n}{Route}\PYG{o}{[}\PYG{n}{S}\PYG{o}{.}\PYG{n+na}{get}\PYG{o}{(}\PYG{n}{mRoutesRequest}\PYG{o}{.}\PYG{n+na}{getOrigin}\PYG{o}{().}\PYG{n+na}{getSemanticId}\PYG{o}{()).}\PYG{n+na}{size}\PYG{o}{()];}
		
		\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{;}
		\PYG{k}{for} \PYG{o}{(}\PYG{n}{StationQuadruple} \PYG{n}{quad} \PYG{o}{:} \PYG{n}{S}\PYG{o}{.}\PYG{n+na}{get}\PYG{o}{(}\PYG{n}{mRoutesRequest}\PYG{o}{.}\PYG{n+na}{getOrigin}\PYG{o}{().}\PYG{n+na}{getSemanticId}\PYG{o}{())}
		\PYG{o}{)} \PYG{o}{\PYGZob{}}
			\PYG{c+c1}{// it will iterate over all legs}
			\PYG{n}{StationQuadruple} \PYG{n}{it} \PYG{o}{=} \PYG{n}{quad}\PYG{o}{;}
			\PYG{n}{List}\PYG{o}{\PYGZlt{}}\PYG{n}{RouteLeg}\PYG{o}{\PYGZgt{}} \PYG{n}{legs} \PYG{o}{=} \PYG{k}{new} \PYG{n}{ArrayList}\PYG{o}{\PYGZlt{}\PYGZgt{}();}
			
			\PYG{k}{while} \PYG{o}{(!}\PYG{n}{Objects}\PYG{o}{.}\PYG{n+na}{equals}\PYG{o}{(}\PYG{n}{it}\PYG{o}{.}\PYG{n+na}{arrivalConnection}\PYG{o}{.}\PYG{n+na}{arrivalStationUri}\PYG{o}{,} \PYG{n}{mRoutesRequest}\PYG{o}{.}\PYG{n+na}{getDestination}\PYG{o}{().}\PYG{n+na}{getSemanticId}\PYG{o}{()))} \PYG{o}{\PYGZob{}}
				\PYG{c+c1}{// use it.departureConnection and it.arrivalConnection to construct legs of this journey}
				\PYG{n}{legs}\PYG{o}{.}\PYG{n+na}{add}\PYG{o}{(...);}
				\PYG{n}{it} \PYG{o}{=} \PYG{n}{getFirstReachableConnection}\PYG{o}{(}\PYG{n}{it}\PYG{o}{);}
			\PYG{o}{\PYGZcb{}}
			
			\PYG{n}{routes}\PYG{o}{[}\PYG{n}{i}\PYG{o}{++]} \PYG{o}{=} \PYG{k}{new} \PYG{n}{Route}\PYG{o}{(}\PYG{n}{legs}\PYG{o}{);}
		\PYG{o}{\PYGZcb{}}
\end{Verbatim}
