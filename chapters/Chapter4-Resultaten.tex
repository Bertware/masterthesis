% !TeX spellcheck = nl_NL
\begin{savequote}[0.55\linewidth]
	``Inspirational quote''
	\qauthor{\textasciitilde Source}
\end{savequote}

\chapter{Resultaten}
\label{chap:resultaten}

Om te voorkomen dat de keuze van het geteste station of route de objectieve metingen vertekent, werden de opzoekingen van echte gebruikers gebruikt op 2 mei 2018\footnote{https://gtfs.irail.be/logs}. Om de duur van de testen enigszins binnen de perken te houden, worden niet alle opzoekingen getest, maar telkens een willekeurig gekozen selectie. Deze selectie werd gemaakt door uit de chronologische logboeken met zoekopdrachten telkens de n-de zoekopdracht te gebruiken.

Voor de alle tests werd gebruik gemaakt van een HTC 10 of HTC One, verbonden met internet via wifi (ping 26ms, downloadsnelheid 42mbps, uploadsnelheid 9mbps), tenzij anders vermeld. Het toestel werd niet gebruikt tijdens de testen, en er werden geen achtergrondapplicaties uitgevoerd. De metingen werden automatisch uitgevoerd met behulp van \foreign{instrumented tests}. Metingen van Linked Connections (LC) gebruiken de LoganSquare JSON parser.

De HTC 10 is een \foreign{flagship} smartphone, uitgebracht in maart 2016. Deze beschikt over een krachtige Snapdragon 820 processor en 4GB ram. De HTC One daarintegen is een \foreign{flagship} smartphone uit 2013, welke over een oude Snapdragon 800 processor en 2GB ram beschikt. Het HTC 10 toestel komt overeen met moderne toestel bovenaan in het mid-range aanbod. Dit toestel biedt goede prestaties en zullen we gebruiken om de performantie van Linked Connections op toestellen van 400 a 600 euro te testen. De HTC One komt op vlak van prestaties overeen met low-end toestellen en oudere mid-range toestellen, en komt ongeveer overeen met de prestaties van een paar jaar oude smartphone van 200 euro. Op deze manier krijgen we een indicatie van de performantie voor alle smartphonegebruikers.

% TODO: afbeelding met schaal?

\section{Liveboards}
\subsection{Metingen}
\begin{figure}[h]
	\centering
	\includegraphics[width=0.80\textwidth]{Optimalisaties_liveboards.eps}
		\caption[Gemeten laadtijd liveboards]{De gemeten laadtijd voor liveboards gebruikmakend van een HTC 10 voor 262 opzoekingen gebaseerd op de iRail logs. }
	\label{fig:liveboardlabtest}
\end{figure}
\begin{table}[h]
	\begin{tabular}{| c | c | c | c | c | c |}
		\hline
		Variant & parser & cache & minimaal (ms) & gemiddelde (ms) & maximaal (ms)\\
		\hline
		LC op toestel & org.json & nee & 302 &  595 &  3471 \\
		LC op toestel & org.json & ja & 409 &  516  &  3599 \\
		LC op toestel & LoganSquare & nee & 392 & 597 & 2027 \\
		LC op toestel & LoganSquare & ja  & 166 & 313 & 3428 \\
		
		LC op server &&&  232 & 397 &  1421\\
		\hline
	\end{tabular}
	\caption[Gemeten laadtijd liveboards]{De gemeten laadtijd voor het eerste resultaat liveboards gebruikmakend van een HTC 10 voor 262 opzoekingen gebaseerd op de iRail logs. }
	\label{tab:liveboardlabtest}
\end{table}

In tabel \ref{tab:liveboardlabtest} en grafiek \ref{fig:liveboardlabtest} zijn de resultaten zichtbaar van een benchmark waarbij 262 stations opgezocht werden, ongeveer 5\% van de opzoekingen door gebruikers op 2 mei 2018. Telkens is de minimale, gemiddelde en maximale responstijd gemeten. Dit zowel gebruikmakend van de standaard JSON parser (\foreign{org.json}) en gebruikmakend van de \foreign{LoganSquare} parser. Ook werd de test herhaald met cache in- en uitgeschakeld, om zo het effect hiervan te meten. Tot slot werd dezelfde test herhaald gebruikmakend van data afkomstig van de LC2Irail web applicatie om een vergelijking tussen de twee methodes te kunnen maken. Deze cijfers geven slechts een indicatie van de snelheid - een volledige en diepgaande statistische analyse van de performantieverschillen tussen verschillende implementatiedetails van dezelfde techniek valt wegens tijdsgebrek buiten het bereik van deze masterproef.

In deze cijfers is invloed van de cache wel duidelijk merkbaar. We zien wel een duidelijk verschil tussen de parsers: terwijl bij gebruik van de \foreign{LoganSquare} parser de gemiddelde laadtijd bijna halveert, terwijl het effect van de cache bij het gebruik van de \foreign{org.json} parser veel kleiner is. Wanneer de cache uitgeschakeld is is het verschil tussen de parsers verwaarloosbaar. Dit is te verklaren door het feit dat voor het tonen van vertrekken of aankomsten relatief weinig data nodig is: in de meeste gevallen volstaat een enkele Linked Connections pagina.

Om een exact beeld te vormen van de prestaties, zoeken we een duizendtal liveboards op. Hiervoor kiezen we telkens de vijfde opzoeking uit de iRail logs. Voor elk liveboard worden twintig resultaten geladen. De resultaten hiervan zijn zichtbaar in grafieken \ref{fig:liveboardsDiefBest}, \ref{fig:liveboardsDiefAvg} en \ref{fig:liveboardsDiefSlechtst}, respectievelijk voor het tiende, vijftigste en negentigste percentiel. Uit deze grafieken kunnen we duidelijke trends zien:
\begin{itemize}
\item In de snelste gevallen is de serverimplementatie sneller. Hiervoor kunnen we verschillende oorzaken aanwijzen: 
	\begin{itemize}
		\item De serverimplementatie kan resultaten op een specifieke vraag cachen, terwijl de lokale implementatie deze steeds zal herberekenen vanaf Linked Connections pagina's.
		\item De serverimplementatie hoeft minder data te versturen. Ook het parsen van het antwoord gaat sneller, gezien slechts een kleine hoeveelheid data verwerkt moet worden en er verder geen berekeningen moeten gebeuren.
	\end{itemize}
	\item Terwijl in de snelste gevallen de serverimplementatie sneller is, is dit verschil beperkt tot ongeveer 60 milliseconden voor het eerste resultaat. Dit is in praktijk amper merkbaar voor gebruikers %TODO: citation needed
	\item Wanneer we naar de mediane performantie kijken, is Linked Connections duidelijk sneller voor de eerste resultaten. Dit snelheidsverschil is aanzienlijk, en vooral te wijten aan het feit dat Linked Connections volledige ondersteuning biedt voor incrementele resultaten, waarbij de server steeds meerdere pagina's zal overlopen voor een antwoord gegeven wordt; Naarmate meer resultaten geladen worden, vormt het overlopen van meerdere pagina's een voordeel voor de serverimplementatie: Zo zullen in daluren sneller resultaten geladen worden door de snellere toegang tot Linked Connections pagina's, terwijl bij Linked Connections sprake is van een \foreign{overhead} door het laden van te veel data. Hierbij zien we dat hoe sneller het toestel, hoe langer Linked Connections het snelst blijft. Ook blijft het verschil tussen Linked Connections en LC2Irail beperkt op de HTC 10, terwijl dit verschil aanzienlijk oploopt op de HTC One.
	\item In alle gevallen is er een sterke gelijkenis tussen de curves voor LC2Irail op het HTC 10 toestel en het HTC One toestel. Deze zijn enkel een relatief kleine afstand in tijd verschoven, wat verklaart kan worden door de lage belasting voor het mobiele toestel wanneer een RPC API gebruikt wordt.
	\item Het verschil in laadtijd tussen Linked Connections op de twee toestellen loopt lineair op met de benodigde laadtijd om resultaten te laden. Zo zien we dat in het slechtste geval dubbel zoveel tijd benodigd is op de HTC One in vergelijking met de HTC 10.
\end{itemize}

\begin{figure}[h]
	\centering
	\includegraphics[width=1.00\textwidth]{boxplot_liveboards_1.eps}
	\caption[Laadtijd eerste resultaat liveboard in functie van toestel en technologie]{Laadtijd eerste resultaat liveboard in functie van toestel en technologie.}
	\label{fig:liveboardsBoxplot1}
\end{figure}

\begin{figure}[h]
	\centering
	\includegraphics[width=1.00\textwidth]{boxplot_liveboards_10.eps}
	\caption[Laadtijd tiende resultaat liveboard in functie van toestel en technologie]{Laadtijd tiende resultaat liveboard in functie van toestel en technologie.}
	\label{fig:liveboardsBoxplot10}
\end{figure}

\begin{figure}[h]
	\centering
	\includegraphics[width=1.00\textwidth]{dief_liveboards_best.eps}
	\caption[Aantal resultaten liveboards in functie van de tijd]{Het aantal resultaten in functie van de verlopen tijd.}
	\label{fig:liveboardsDiefBest}
\end{figure}

\begin{figure}[h]
	\centering
	\includegraphics[width=1.00\textwidth]{dief_liveboards_gemiddeld.eps}
	\caption[Aantal resultaten liveboards in functie van de tijd]{Het aantal resultaten in functie van de verlopen tijd.}
	\label{fig:liveboardsDiefAvg}
\end{figure}

\begin{figure}[h]
	\centering
	\includegraphics[width=1.00\textwidth]{dief_liveboards_slechtst.eps}
	\caption[Aantal resultaten liveboards in functie van de tijd]{Het aantal resultaten in functie van de verlopen tijd.}
	\label{fig:liveboardsDiefSlechtst}
\end{figure}

Waneer we nu naar de spreiding van de laadtijden kijken, zichtbaar in figuren \ref{fig:liveboardsBoxplot1} en \ref{fig:liveboardsBoxplot10} zien we ook hier duidelijke verschillen tussen de verschillende methodes. Zo zien we dat bij gebruik van een RPC API de mediaan van de laadtijd ongeveer gelijk is tussen verschillende toestellen, en de interkwartielafstand relatief klein is, wat op een kleine spreiding en dus consistente resultaten duidt. Bij gebruik van Linked Connections zien we duidelijke verschillen tussen de mediaan van de laadtijd bij verschillende toestellen. Ook de interkwartielafstand varieert tussen toestellen: zo is een ouder toestel niet enkel trager, maar is ook de spreiding veel groter, en zijn de resultaten dus minder consistent op oudere (tragere) toestellen.

\subsection{Ervaringen}
Wanneer we nu naar de ervaringen van gebruikers gaan kijken, stemmen deze ongeveer overeen met wat we zouden verwachten na het bekijken van voorgaande grafieken. 

Zoals we in figuren \ref{fig:liveboardsBoxplot1} en \ref{fig:liveboardsBoxplot10} konden zien blijkt uit testen dat de performantie van LC2Irail consistenter is. Ook bij de gebruikerservaring zien we dit terugkomen. Wanneer de ervaren snelheid wordt uitgezet in een boxplot per implementatie, zichtbaar in figuur \ref{fig:liveboardsUx}, zien we net als bij de testen dat voor LC2Irail een heel consistente beoordeling wordt gegeven, terwijl deze voor Linked Connections veel meer uitgespreid, én iets lager ligt.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.80\textwidth]{boxplot_liveboards_ux.eps}
	\caption[Ervaren snelheid van liveboards]{De ervaren snelheid op een schaal 1-7 van vertrekken en aankomsten voor LC2Irail en Linked Connections, gebaseerd op 17 user tests.}
	\label{fig:liveboardsUx}
\end{figure}

Hoewel 12 van de 17 testpersonen aangeeft licht tot extreem tevreden te zijn met de laadsnelheid, geven slechts 2 personen aan dat de lijst met vertrekken sneller laadt bij de lokale implementatie van Linked Connections. Nog eens 3 personen geven aan beide implementaties even snel te ervaren.

Wanneer we gaan kijken naar de verschillen tussen de JSON parsers, blijkt dat beide parsers ongeveer even goed presteren in de ogen van de gebruikers. Respectievelijk 5 op 7 en 7 op 10 gebruikers zijn neutraal of tevreden, en bij beide varianten is er telkens een gebruiker neutraal. Deze vergelijking is echter slechts een indicatie, en is door te kleine steekproeven ongeschikt om te veralgemenen naar een grotere populatie.

Wanneer we kijken naar de gemeten prestatieverschillen tussen beide JSON parsers tijdens de usertests, zien we een duidelijk verschil, waarbij het 90e percentiel van de laadtijd onder de LoganSquare parser lager ligt dan de mediane laadtijd van de org.json parser. Dit verschil lijkt echter geen invloed te hebben op de ervaringen van gebruikers, vermoedelijk omdat men beide reeds als performant genoeg ervaart.

Tot slot werden alle testpersonen ook expliciet gevraagd welke implementatie ze als sneller ervaarden. Hierbij waren de antwoorden verdeeld: acht personen kozen de eerste variant, vier personen hadden geen mening, en vijf personen kozen de tweede variant. Hierbij valt op dat bij de eerste lokale implementatie, 

\section{Routes}

\subsection{Metingen}
\begin{figure}[h]
	\centering
	\includegraphics[width=0.80\textwidth]{Optimalisaties_routes.eps}
	\caption[Gemeten laadtijd routes]{De gemeten laadtijd voor routes gebruikmakend van een HTC 10 voor 779 opzoekingen gebaseerd op de iRail logs.}
	\label{fig:routelabtest}
\end{figure}
\begin{table}[h]
	\begin{tabular}{| c | c | c | c | c | c |}
		\hline
		Variant & parser & cache & minimaal (ms) & gemiddelde (ms) & maximaal (ms)\\
		\hline
		LC op toestel & org.json & nee & 401 & 3539 & 8531\\
		LC op toestel & org.json & ja & 221 & 2172 & 6960 \\
		LC op toestel & LoganSquare & nee &  386 & 3374 & 7554 \\
		LC op toestel & LoganSquare & ja  & 233 & 1973 & 7640 \\
		
		LC op server &&&  27 & 1126 & 3374\\
		\hline
	\end{tabular}
	\caption[Gemeten laadtijd routes]{De gemeten laadtijd voor routes gebruikmakend van een HTC 10 voor 779 opzoekingen gebaseerd op de iRail logs.}
	\label{tab:routelabtest}
\end{table}

In tabel \ref{tab:routelabtest} en grafiek \ref{fig:routelabtest} zijn de resultaten zichtbaar van een benchmark waarbij 779 routes opgezocht werden, ongeveer 5\% van de opzoekingen door gebruikers op 2 mei 2018. Telkens is de minimale, gemiddelde en maximale responstijd gemeten. Dit zowel gebruikmakend van de standaard JSON parser (\foreign{org.json}) en gebruikmakend van de \foreign{LoganSquare} parser. Ook werd de test herhaald met cache in- en uitgeschakeld, om zo het effect hiervan te meten. Tot slot werd dezelfde test herhaald gebruikmakend van data afkomstig van de LC2Irail web applicatie om een vergelijking tussen de twee methodes te kunnen maken. Deze cijfers geven slechts een indicatie van de snelheid - een volledige en diepgaande statistische analyse van de performantieverschillen tussen verschillende implementatiedetails van dezelfde techniek valt wegens tijdsgebrek buiten het bereik van deze masterproef.

Net zoals bij liveboards is ook hier de invloed van de cache duidelijk merkbaar. Vergeleken met dezelfde analyse voor Liveboards (figuur \ref{fig:liveboardlabtest}), zien we hier een minder groot verschil tussen de parsers: er moeten grote hoeveelheden data verwerkt worden, en het algoritme om de data te verwerken is het zwaarst van de drie endpoints.

Om ook hier een exact beeld te vormen van de prestaties, maken we ook hier een duizendtal opzoekingen. Hiervoor kiezen we telkens de vijfde opzoeking uit de iRail logs. Voor elke route wordt gepoogd 10 resultaten geladen. De resultaten hiervan zijn zichtbaar in grafieken \ref{fig:routesDiefBest}, \ref{fig:routesDiefAvg} en \ref{fig:routesDiefSlechtst}, respectievelijk voor het tiende, vijftigste en negentigste percentiel.

\begin{figure}[h]
	\centering
	\includegraphics[width=1.00\textwidth]{dief_routes_best.eps}
	\caption[Aantal resultaten routes in functie van de tijd]{Het aantal resultaten in functie van de verlopen tijd.}
	\label{fig:routesDiefBest}
\end{figure}

\begin{figure}[h]
	\centering
	\includegraphics[width=1.00\textwidth]{dief_routes_gemiddeld.eps}
	\caption[Aantal resultaten routes in functie van de tijd]{Het aantal resultaten in functie van de verlopen tijd.}
	\label{fig:routesDiefAvg}
\end{figure}

\begin{figure}[h]
	\centering
	\includegraphics[width=1.00\textwidth]{dief_routes_slechtst.eps}
	\caption[Aantal resultaten routes in functie van de tijd]{Het aantal resultaten in functie van de verlopen tijd.}
	\label{fig:routesDiefSlechtst}
\end{figure}

Uit deze grafieken kunnen we opnieuw duidelijke verschillen zien:
\begin{itemize}
	\item In alle grafieken en voor alle testen, hebben de curves een gelijkaardige vorm, waarbij er na een relatief lange wachttijd aan snel tempo resultaten geladen worden: in het geval van Linked Connections is voor de eerste opzoeking telkens een relatief grote hoeveelheid data nodig is, waarna slechts één of twee extra pagina's moeten opgehaald worden om het volgend resultaat te bepalen. In het geval van LC2Irail worden resultaten in grote blokken binnengehaald, waarbij vanaf de tweede opzoeking reeds veel data in cache zit. In het geval van LC2Irail worden resultaten ook onmiddelijk voor grote intervals opgehaald, om zo het aantal verzoeken te beperken. 
	\item Terwijl in het alle gevallen Linked Connections beter presteert op de HTC 10, presteert het slechter op de HTC One. 
	\item Opnieuw presteert LC2Irail op beide toestellen gelijkaardig, met slechts een kleine verschuiving in tijd tussen beide curves.
	\item Terwijl in het slechtste geval bijna alle varianten gelijk presteren, loopt Linked Connections op de HTC 10 enorm achter.
\end{itemize}

Wanneer we nu specifiek naar de verdelingen kijken, gevisualiseerd door middel van box plots in figuur \ref{fig:routesBoxplot1} en \ref{fig:routesBoxplot10}, Zien we ook hier duidelijk hoe LC2Irail gelijke prestaties heeft op beide toestellen, terwijl de prestaties van Linked Connections sterk variëren per toestel. Op de HTC 10 zal al meer dan 75\% van de opzoekingen geladen zijn op het moment dat LC2Irail op hetzelfde toestel minder dan 25\% van de verzoeken beantwoordt heeft. Op het HTC One toestel is dit echter omgekeerd, en nog extremer. 

\begin{figure}[h]
	\centering
	\includegraphics[width=0.80\textwidth]{boxplot_routes_1.eps}
	\caption[Laadtijd eerste resultaat route in functie van toestel en technologie]{Laadtijd eerste resultaat route in functie van toestel en technologie.}
	\label{fig:routesBoxplot1}
\end{figure}

\begin{figure}[h]
	\centering
	\includegraphics[width=0.80\textwidth]{boxplot_routes_10.eps}
	\caption[Laadtijd tiende resultaat route in functie van toestel en technologie]{Laadtijd tiende resultaat route in functie van toestel en technologie.}
	\label{fig:routesBoxplot10}
\end{figure}

\subsection{Ervaringen}

Op vlak van gebruikerservaring verwachten we dat gebruikers net zoals bij Liveboards de implementatie op basis van LC2Irail consistenter zullen beoordelen, en dat snelheid voor beide implementaties ongeveer gelijk ervaren wordt.

Wanneer we nu de resultaten van user testing vergelijken met de verwachtingen, blijken deze verwachtingen grotendeels in vervulling te gaan. In figuur \ref{fig:routesUx} is te zien dat de prestaties van LC2Irail iets consistenter beoordeeld worden, en LC2Irail tevens een betere beoordeling krijgt dan Linked Connections. 

Wanneer we voor routes beide JSON parsers vergelijken, zien we dat voor de LoganSquare parser de proefpersonen een meer uitgesproken mening hadden: er waren zowel meer tevreden als ontevreden personen, terwijl bij de \foreign{org.json} parser veel mensen neutraal waren. Dit gaat echter in tegen een praktijktest waarbij enkele gebruikers achtereenvolgens een versie gebruikmakend van de \foreign{org.json} en \foreign{LoganSquare} parser voorgeschoteld kregen, gaven deze telkens aan de versie op basis van \foreign{LoganSquare} sneller te ervaren, zowel op goedkope als dure smartphones. Hieruit besluiten we dat de gebruikerstests, opgedeeld per parser, te kleine steekproeven zijn om een algemene conclusie te vormen over de invloed van de parsers.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.80\textwidth]{boxplot_routes_ux.eps}
	\caption[Ervaren snelheid van routes]{De ervaren snelheid op een schaal 1-7 van routes voor LC2Irail en Linked Connections, gebaseerd op 17 user tests.}
	\label{fig:routesUx}
\end{figure}

\section{Voertuigen}

\subsection{Metingen}
Het opzoeken van het traject dat een voertuig aflegt heeft als groot verschil dat incrementele resultaten niet door de gebruikte applicatie ondersteund worden. De reden hiervoor is dat het traject van het voertuig het enige en volledige resultaat is dat de gebruiker wenst, in tegenstelling tot liveboards en routes, waar de gebruiker niet het volledige, maar slechts een deel van het resultaat wenst te zien. 

Dit is ook de opzoeking die het meeste data vereist bij Linked Connections: alle pagina's moeten doorzocht worden op connecties met betrekking tot één specifiek voertuig. Dit voertuig komt slechts in een relatief beperkt aantal pagina's voor, gezien het voertuig slechts enkele uren rijdt, en het tijdstip van eerste vertrek en aankomst onbekend zijn. Zoals eerder vermeld %TODO: referntie
zijn hier enkele oplossingen voor, zoals het gebruik van een index. We definiëren een index in deze context als een lijst van alle treinen voor een bepaalde periode (in dit geval mei 2018) en het tijdstip van hun eerste vertrek.

Om een idee te krijgen van de invloed van deze index, alsook van het gebruik van een cachegeheugen voor de Linked Connections pagina's bij deze opzoekingen, werden 102 voertuigen opgezocht, voor alle combinaties van cache en index gebruik. Tevens werd een extra test gedaan met een cache die in het RAM geheugen geplaatst wordt (in tegenstelling tot het flashgeheugen van het toestel), en een vergelijkende test waarbij de Linked Connections server gebruikt werd. De minimale, gemiddelde en maximale opzoektijd hiervoor is te zien in tabel \ref{tab:vehiclelabtest}. De gemiddelde resultaten zijn tevens gevisualiseerd in figuur \ref{fig:vehiclelabtest}.

\begin{figure}[ht]
	\centering
	\includegraphics[width=1.00\textwidth]{Optimalisaties_voertuigen.eps}
	\caption[Gemeten laadtijd voertuigen]{De gemeten laadtijd voor voertuigen gebruikmakend van een HTC 10 voor 102 opzoekingen gebaseerd op de iRail logs. }
	\label{fig:vehiclelabtest}
\end{figure}

\begin{table}[ht]
	\begin{tabular}{| c | c | c | c | c | c | c |}
		\hline
		Variant & parser & cache & index & minimaal (ms) & gemiddelde (ms) & maximaal (ms)\\
		\hline
		LC op toestel & org.json & nee & nee & 540 & 6764 & 12676 \\
		LC op toestel & org.json & ja & nee & 483 & 6488 & 10921 \\
		
		LC op toestel & org.json & nee & ja & 2638 & 4443 & 10956 \\
		LC op toestel & org.json & ja & ja &  2440 & 4066 & 6003\\
		LC op toestel & org.json & RAM & ja & 2263 & 3912 & 5763 \\
		LC op toestel & LoganSquare & nee & ja &  1860 & 3283 & 5374 \\
		LC op toestel & LoganSquare & ja  & ja & 1195 & 1925 & 2888 \\
		
		LC op server &&&&  264 & 713 & 5068 \\
		\hline
	\end{tabular}
	\caption[Gemeten laadtijd voertuigen]{De gemeten laadtijd voor voertuigen gebruikmakend van een HTC 10 voor 102 opzoekingen gebaseerd op de iRail logs. }
	\label{tab:vehiclelabtest}
\end{table}

Het is duidelijk dat de standaard implementatie zeer slecht presteert. Ook het gebruik van een cachegeheugen brengt hierbij niet veel beterschap. Wanneer echter een index toegevoegd worden, is een drastische verbetering merkbaar. Het gemiddelde daalt in deze beeperkte test met ongeveer een derde. Toevoeging van een cachegeheugen, op flash of in het RAM geheugen, brengt ook hier slechts weinig beterschap. 

Een tweede grote verbetering kan behaald worden door het gebruik van de eerder besproken LoganSquare parser. Hierbij zien we ook een veel grotere verbetering door cachegebruik dan bij de org.json parser. Dit is logisch, gezien bij het gebruik van de LoganSquare parser het verwerken van de data relatief gezien minder tijd in beslag neemt - het ophalen van data wordt dus belangrijker. Op het eerste zicht blijven alle lokale varianten veel trager dan de serverimplementatie, die sneller door pagina's kan zoeken.

We onderzoeken nu het verschil tussen de lokale implementatie en de serverimplementatie in detail. Hiervoor zoeken we 1620 voertuigen op die plaatsvinden op 6 mei 2018. Dit wordt enerzijds gedaan voor de lokale implementatie die gebruik maakt van de LoganSquare parser, cache en lokale index, en anderzijds voor de serverimplementatie, die server-side over dezelfde index en een cache beschikt.

Wanneer we kijken naar de box-plot van de responstijd, weergegeven in figuur \ref{fig:vehicleboxplot}, zien we dat de lokale implementatie duidelijk slechter presteert. Op beide toestellen is LC2Irail sneller dan Linked Connections. Bij de HTC 10, een snel toestel, valt dit nog enigszins mee, maar op de HTC One zijn de meeste resultaten binnen 3000 milliseconden geladen, terwijl op dat moment nog geen 25\% van de opzoekingen via Linked Connections uitgevoerd werd. Ook zien we hier dat LC2Irail consistente prestaties biedt: beide box plots zijn praktisch identiek, op wat uitlopers na. Voor Linked Connections zien we echter dat, net zoals voor het opzoeken van liveboards en routes, de spreiding van de benodigde tijd afhangt van het toestel: een traag toestel heeft een grotere variatie in de laadtijd.

\begin{figure}[h]
	\centering
	\includegraphics[width=1.00\textwidth]{boxplot_vehicles.eps}
	\caption[Prestaties voor het laden van voertuigen]{De prestaties voor het laden van voertuigen, gemeten door alle voertuigen, beschreven in Linked Connections, voor 6 mei op te zoeken.}
	\label{fig:vehicleboxplot}
\end{figure}

%\begin{figure}[h]
%	\centering
%	\includegraphics[width=1.00\textwidth]{distribution_vehicle_loading_cummulatief.eps}
%	\caption[Cummulatieve kans op laden van voertuig]{De kans dat een voertuig geladen is in functie van de verlopen tijd.}
%	\label{fig:vehiclecummulatief}
%\end{figure}

\subsection{Ervaringen}
Wanneer we nu de resultaten van de user-testing bekijken, zien we zoals verwacht dat het laden van voertuigen beduidend slechter scoort wanneer de lokale Linked Connections implementatie gebruikt wordt, vergeleken met wanneer de serverimplementatie gebruikt werd. In figuur \ref{fig:vehicleboxplot} is dit duidelijk zichtbaar. Zo beoordelen de meeste gebruikers Linked connections slechts als "gemiddeld", terwijl de meerderheid van de gebruikers de LC2Irail variant als "Zeer snel" bestempelde. Ook zien we hier, net als bij liveboards en routes, dat er voor Linked Connections een veel grotere spreiding is in de gegeven antwoorden, terwijl  bij LC2Irail iedereen het er over eens lijkt dat deze implementatie snel is.

\begin{figure}[h]
	\centering
	\includegraphics[width=1.00\textwidth]{boxplot_vehicles_ux.eps}
	\caption[Ervaren snelheid van routes]{De ervaren snelheid op een schaal 1-7 van routes voor LC2Irail en Linked Connections, gebaseerd op 17 user tests.}
	\label{fig:vehiclesUx}
\end{figure}

Personen die de lokale implementatie op basis van LoganSquare testten, beoordeelden de laadtijd iets beter vergeleken met de groep die de implementatie op basis van de \foreign{org.json} parser testte. Ondanks dat de testgroep onvoldoende groot was om een veralgemening te kunnen maken, kunnen we wel stellen dat er een grote kans is dat verbeteringen in de implementatie de snelheid verder omlaag kunnen brengen, en zo de gebruikerservaring kunnen verbeteren. Gezien bij het berekenen van voertuigen het meeste data nodig is, is hier de impact van implementatiedetails het grootst.


Wanneer de gebruiker gevraagd werd te kiezen, koos slechts één gebruiker voor de lokale implementatie in dit onderdeel. Vijf gebruikers hadden geen specifieke voorkeur voor een specifieke implementatie, ook al beoordeelden vier van hen de lokale implementatie als trager.
Hieruit concluderen we dat gebruikers de laadtijd van voertuigdata acceptabel vinden wanneer deze onder 1 seconde blijft. Een seconde langer laden, wat het geval is bij de lokale implementatie, wordt door de meeste personen niet meer als snel ervaren.


\section{Keuze van de gebruiker}

Voor alle soorten informatie (liveboards, routes, en voertuigen) lijkt Linked Connections een slechtere gebruikerservaring dan LC2Irail, in termen van laadtijd. Hierbij dienen we op te merken dat dit verschil bij liveboards slechts zeer beperkt is, en het laden nog steeds als snel werd ervaren. Voor routes bestempelden enkele personen Linked Connections als traag, maar blijft het verschil beperkt. Bij voertuigen blijkt echter dat Linked Connections door drie kwart van de gebruikers als trager werd ervaren, waarbij Linked Connections niet enkel relatief slechter scoort, maar ook in absolute termen slechts door een minderheid van de gebruikers als snel wordt ervaren. 

Dit zien we ook terug in de antwoorden wanneer gebruikers gevraagd werd te kiezen tussen beide implementaties. Voor vertrekken zijn er vier gebruikers die beide implementaties even snel vinden, terwijl van de overige 13 slechts vijf kiezen voor Linked Connections. Bij routes en voertuigen scoort Linked Connections zoals verwacht slechter: er zijn respectievelijk slechts twee en een gebruiker die voor Linked Connections kiezen zijn. Hierbij zijn er respectievelijk twee en vijf gebruikers die geen verschil tussen de implementaties merkten.

Terwijl de meerderheid van de gebruikers steeds voor LC2Irail koos, kantelt deze balans echter volledig om wanneer gebruikers worden gevraagd om met alle aspecten rekening te houden: zodra ook  offline gebruik meespeelt, kiezen nog maar vijf gebruikers voor LC2Irail. Twee gebruikers zijn onbeslist, de andere tien gebruikers kiezen voor Linked Connections. Hieruit blijkt duidelijk dat gebruikers enige snelheid willen opgeven in ruil voor offline opzoekingen. Zeven gebruikers laten weten dat ze een hybride systeem ideaal zou zijn, waarbij de snelheid van LC2Irail gecombineerd wordt met Linked Connections als offline alternatief. Wanneer deze gebruikers alsnog verplicht werden te kiezen, waren hun keuzes gelijk verdeeld, afhankelijk van de persoonlijke nood om offline te kunnen opzoeken.

\section{Beperkingen}
\subsection{Kleine steekproef voor user testing}
Zoals eerder vermeld ontbreekt op het moment van schrijven nog cruciale informatie in Linked Connections, zoals of een voertuig al dan niet afgeschaft is, en op welk perron een voertuig aankomt. Hierdoor moesten we terugvallen op user-testing onder begeleiding, om gebruikers aan te sporen hun gebruikelijke opzoekingen te doen en te polsen naar hun ervaringen. Dit neemt relatief veel tijd in beslag, waardoor weinig mensen én zin, én tijd hebben. Voorts neemt deze methode van testen ook veel tijd in beslag voor de onderzoeker. 

De groep testgebruikers is wel gevarieerd, zowel in persoonlijke eigenschappen zoals leeftijd, als in reisgewoontes per trein. Wanneer de gehele testgroep duidelijk de voorkeur geeft aan een bepaalde variant, kunnen we deze keuze veralgemenen naar de gehele populatie. Wanneer er echter geen grote meerderheid voor eenzelfde variant kiest, moeten we voorzichtig zijn met conclusies.

\subsection{Beperkt aantal unieke toestellen getest}
Uit de voorgaande secties blijkt dat het gebruikte toestel van groot belang is voor de prestaties van de lokale Linked Connections implementatie. Tijdens het user-testen werd gebruik gemaakt van twaalf verschillende smartphones. Dit aantal is relatief beperkt in vergelijking met het aanbod op de huidige smartphonemarkt. Eventuele verder onderzoek zal de prestaties van Linked Connections op verschillende toestellen moeten vastleggen.

\subsection{Processorverbruik niet meetbaar}
De Android CPU Profiler beïnvloed de prestaties van de applicatie zodanig dat het onmogelijk is om een correct beeld te krijgen van het processorverbruik. Er kan een beeld gevormd worden welke onderdelen van de applicatie het meest processortijd vragen, maar exacte tijdsmetingen zijn niet mogelijk. Deze problemen worden ook door andere Android ontwikkelaars op internet beschreven\footnote{\url{https://stackoverflow.com/questions/49555983/background-concurrent-copying-gc-freed}}. Deze problemen treden op door de nieuwe Android CPU profiler, die zelf teveel processortijd op het apparaat vereist.

\subsection{Prestaties zijn sterk afhankelijk van implementatiedetails}
Zoals blijkt uit grafieken %TODO: REFERENTIE
is de performantie van de lokale Linked Connections implementatie sterk afhankelijk van details in de implementatie - Het is dus niet enkel belangrijk om de algoritmes te optimalizeren, maar ook om rekening te houden met processen zoals Garbage Collection. Dit werd pas in een gevorderd stadium van de proef vastgesteld. Het is mogelijk dat de resultaten in dit onderzoek nog verder verbeterd kunnen worden door dezelfde algoritmes efficiënter te implementeren.